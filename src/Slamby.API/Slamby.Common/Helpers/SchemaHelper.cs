using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json.Linq;

namespace Slamby.Common.Helpers
{
    public static class SchemaHelper
    {
        public static class Types
        {
            public const string Object = "object";
            public const string Array = "array";
            public const string Attachment = "attachment";
            public const string String = "string";
            public const string Long = "long";
            public const string Integer = "integer";
            public const string Short = "short";
            public const string Byte = "byte";
            public const string Double = "double";
            public const string Float = "float";
            public const string Boolean = "boolean";
            public const string Date = "date";
        }

        public static class Elements
        {
            public const string Type = "type";
            public const string Format = "format";
            public const string Properties = "properties";
            public const string Items = "items";
        }

        public static bool IsPrimitiveType(string type)
        {
            var complexTypes = new[] { Types.Object, Types.Array, Types.Attachment };
            return !complexTypes.Any(item => string.Equals(item, type, StringComparison.OrdinalIgnoreCase));
        }

        public static bool IsAttachment(string type)
        {
            return string.Equals(Types.Attachment, type, StringComparison.OrdinalIgnoreCase);
        }

        public static bool IsObject(string type)
        {
            return string.Equals(Types.Object, type, StringComparison.OrdinalIgnoreCase);
        }

        public static bool IsArray(string type)
        {
            return string.Equals(Types.Array, type, StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Returns True for integer schema types: Integer, Long, Short, Byte 
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public static bool IsInteger(string type)
        {
            var integerNumericTypes = new[] { Types.Integer, Types.Long, Types.Short, Types.Byte };
            return integerNumericTypes.Any(item => string.Equals(item, type, StringComparison.OrdinalIgnoreCase));
        }

        public static bool IsDecimal(string type)
        {
            var decimalNumericTypes = new[] { Types.Double, Types.Float };
            return decimalNumericTypes.Any(item => string.Equals(item, type, StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        /// Returns with all schema path and type
        /// </summary>
        /// <param name="obj"></param>
        /// <returns>Key: path; Tuple.Item1: Type; Tuple.Item2: Array item Type if Item1 is array</returns>
        public static IDictionary<string, Tuple<string, string>> GetPaths(object obj)
        {
            return GetPaths(JTokenHelper.GetToken(obj));
        }

        /// <summary>
        /// Returns with all schema path and type
        /// </summary>
        /// <param name="node"></param>
        /// <returns>Key: path; Tuple.Item1: Type; Tuple.Item2: Array item Type if Item1 is array</returns>
        public static IDictionary<string, Tuple<string, string>> GetPaths(JToken node)
        {
            var result = new Dictionary<string, Tuple<string, string>>();

            if (node.Type != JTokenType.Object)
            {
                return result;
            }

            var properties = node.Children<JProperty>().ToList();

            if (node.Parent == null)
            {
                // Process root object
                var type = properties.FirstOrDefault(c => c.Name == Elements.Type)?.Value.Value<string>();
                if (type == Types.Object)
                {
                    var propertiesProperty = properties.FirstOrDefault(c => c.Name == Elements.Properties).Value;
                    GetSchemaPaths(propertiesProperty, result, string.Empty);
                }
            }

            return result;
        }

        private static void GetSchemaPaths(JToken node, IDictionary<string, Tuple<string, string>> result, string path)
        {
            foreach (JProperty property in node.Children<JProperty>())
            {
                var name = property.Name;
                var fullPath = path.AppendSeparator(".") + name;
                // It can be JArray e.g.: ["null", "string"], if it is generated by NJsonSchema
                var type = property.Value.SelectToken(Elements.Type)?.Value<string>();
                var subType = string.Empty;
                var tokenPrefix = string.Empty;

                if (type == Types.Array)
                {
                    tokenPrefix = $"{Elements.Items}.";
                    subType = property.Value.SelectToken($"{tokenPrefix}{Elements.Type}")?.Value<string>();
                }

                result.Add(fullPath, new Tuple<string, string>(type, subType));

                if (type == Types.Object)
                {
                    GetSchemaPaths(property.Value.SelectToken($"{tokenPrefix}{Elements.Properties}"), result, fullPath);
                }
            }
        }
    }
}
